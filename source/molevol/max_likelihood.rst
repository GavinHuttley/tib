.. jupyter-execute::
    :hide-code:

    import set_working_directory

.. margin:: The phylogeny-based maximum likelihood calculation
    
    .. index::
        pair: The phylogeny-based maximum likelihood calculation; screencasts
    
    .. raw:: html
    
        <video width="50%" height="50%" controls>
          <source src="https://cloudstor.aarnet.edu.au/plus/s/xdzQS46fsHj9aQl/download" type="video/mp4">
          Your browser does not support the video tag.
        </video>

Statistical methods for molecular evolutionary analyses
=======================================================

.. todo:: **This is important!** Define process, model etc.. How the two terms can be cofused. Refer to likelihood calculation..

The most widely used phylogenetic methods are maximum likelihood or Bayesian. The Bayesian methods incorporate the likelihood calculations and thus inherit many of the assumptions.

Both these approaches are considered "probabilistic", meaning they involve probability calculations under a specific model of evolution. Their popularity in phylogenetics stems from their well developed theoretical foundations. Those foundations facilitate objective inference into the evolution of biological sequences.

Maximum likelihood
------------------

.. math::

    \mathcal{L}(M|D) \propto P(D|M)

The likelihood (:math:`\mathcal{L}`) of a model (:math:`M`) given some data (:math:`D`) is proportional to the conditional probability of :math:`D` given :math:`M`.

Maximum likelihood is a method of estimation. If I have an algebraic representation of how something happens (:math:`M`) I can implement that in code. By assigning some specific values to those terms in :math:`M`, I can calculate a probability the sequences in a data sample were generated by that model. The maximum likelihood method proceeds by modifying model parameter values until the likelihood is maximised.

.. margin:: An equivalent tree for a time-reversible model
    :name: star_tree

    .. jupyter-execute::
        :hide-code:

        from cogent3 import make_tree

        tree = make_tree("(A,B,C)")
        fig = tree.get_figure(style="radial")
        fig.line_width = 4
        fig.marker = 14
        fig.tips_as_text = False
        fig.style_edges("A", line=dict(color="darkgreen"))
        fig.style_edges("B", line=dict(color="orange"))
        fig.style_edges("C", line=dict(color="blue"))
        fig.show(width=300, height=300)

    For models that are unable to resolve the direction of time, this tree shape is actually what is being analysed – the tree root has a trifurcation. This type of tree shape is also referred to as a "star phylogeny".

The elements to compute likelihood
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. margin:: Elements of a phylogenetic model
    :name: tree_align_p

    .. jupyter-execute::
        :hide-code:

        from cogent3 import make_tree

        def make_annotation(text, x, y, fontsize, color):
            annot = dict(text=text, x=x, y=y,
                    showarrow=False, xanchor="left",
                    font=dict(size=fontsize,
                              family="Inconsolata, monospace", color=color))
            return annot

        def add_text_annotation(fig, name_text_colour, fontsize=24):
            """adds an annotation to the figure"""
            annotes = []
            num = 1
            for name, val in name_text_colour.items():
                node = fig.tree.get_node_matching_name(name)
                annot = make_annotation(val["text"], 1.1 * node.x,
                                        node.y, fontsize, val["color"])
                annotes.append(annot)
                if name.startswith("edge"):
                    continue

                annot = make_annotation(f"<b><i>P</i><sub>{num}</sub><b>",
                                        node.x - 0.4, 0.2 + node.y,
                                        fontsize, val["color"])
                annotes.append(annot)

                num += 1

            fig.figure.layout.annotations = tuple(annotes)
            return fig

        tree = make_tree("(A,(B,C))")
        fig = tree.get_figure()
        fig.line_width = 4
        fig.marker = 14
        fig.tips_as_text = False
        fig.style_edges(["A", "edge.0"], line=dict(color="darkgreen"))
        fig.style_edges("B", line=dict(color="orange"))
        fig.style_edges("C", line=dict(color="blue"))
        name_seq_colour = {"A": dict(color="darkgreen", text="C C C G C T"),
                               "B":dict(color="orange", text="T C C G G T"),
                               "C": dict(color="blue", text="C C C G A T"),
                               "edge.0": dict(color="black", text="π"),
                               }

        fig = add_text_annotation(fig, name_seq_colour, fontsize=30)
        fig.show(width=450, height=350)

    The elements of :math:`M` and the data for a phylogeny based likelihood calculation. These are the substitution probability matrices (:blue:`P`, :orange:`P` and :teal:`P`), the frequencies of bases in the unobserved common ancestor (|pi|). This tree relates the sequences shown at the tips which have descended from the unobserved common ancestor.

    *If you hover your cursor over the tree nodes their names will appear in a pop-up.*

Shown in the :ref:`Elements of a phylogenetic model <tree_align_p>` figure are the basic elements required to compute a likelihood.

A tree shape, or tree topology
""""""""""""""""""""""""""""""

To be consistent with the vast majority of models that are in current use, we place the "root" of the tree at the internal node ``edge.0`` (hover your mouse over the nodes to find it) [1]_ [2]_.

.. margin::
  
    .. [1] Why use such models when they sound more complicated? Because mathematically, they are more tractable.
    .. [2] For an unrooted tree of three taxa, there is only one possible tree shape.

The particular :ref:`tree shown <tree_align_p>` includes the :index:`chronological root`. This is the point from which time flows forward until the present. However, the vast majority of models are unable to resolve which way times arrow points. As a consequence, the chronological root cannot be identified and an unrooted tree is used.

|pi| – the state frequencies in the common ancestor
"""""""""""""""""""""""""""""""""""""""""""""""""""

The symbol |pi| (a variable) at the "root" denotes the frequencies of the different sequence states. If we are modelling evolution as a nucleotide process, then |pi| is the frequencies of the nucleotides in the unobserved ancestor. If we were modelling amino acid sequences, it would be the frequency of the amino acids in the unobserved ancestor. The one shown below is again estimated from one alignment [3]_. And these were our estimate of the nucleotide frequencies. So the frequency T is 0.24, C is 0.174, etc.

.. margin::
  
    .. [3] Parameters were estimated for the *BRCA1* gene from the common ancestor of Humans, Chimpanzee and Rhesus macaque using the F81 substitution model :cite:`Felsenstein:1981aa`. The |P| matrix is for the Human branch.

.. jupyter-execute::
    :hide-code:

    from cogent3 import make_table

    pi = make_table(data={'T': [0.2402306967984934],
                             'C': [0.17443502824858756],
                             'A': [0.3747645951035782],
                             'G': [0.21056967984934086]}, digits=3, title="π")
    pi.set_repr_policy(show_shape=False)

.. jupyter-execute::

    pi

|P| – the substitution probability matrices
"""""""""""""""""""""""""""""""""""""""""""

We have |P| matrices, one for each edge (branch) on the tree. These represent the probabilities of changing from one state into another in some period of time. In the example below, the row labels correspond to the state being changed "from", the column labels the state being changed "to". Every element in this matrix is a probability, which means they are bounded between zero and one. Given the row based frame of reference, all elements in a row correspond to the full set of possible outcomes for the "from" state. Accordingly, the row sum must be 1.

.. jupyter-execute::
    :hide-code:

    from cogent3 import make_table

    P = make_table(data={'': ['T', 'C', 'A', 'G'],
                     'T': [0.9935419256306857,
                      0.002041972081761517,
                      0.002041972081761486,
                      0.002041972081761472],
                     'C': [0.0014827058428077274,
                      0.9929826593917318,
                      0.0014827058428077322,
                      0.0014827058428077276],
                     'A': [0.0031855164665990582,
                      0.0031855164665990474,
                      0.9946854700155231,
                      0.003185516466599004],
                     'G': [0.0017898520599076,
                      0.0017898520599075826,
                      0.0017898520599076214,
                      0.9932898056088316]},
                    digits=3, index_name="", title="P<sub>Human</sub>")
    P.set_repr_policy(show_shape=False)

.. jupyter-execute::

    P

Notice that the diagonal element is the largest value in each row. This means it is more likely that nucleotides remain unchanged. This is just one |P| substitution probability matrix [3]_. Given the modest amount of time elapsed since we shared a common ancestor with the Chimpanzee, there is not a huge amount of genetic change and why |P| is dominated by the diagonal.

Example calculation of the probability of an alignment column
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We now use just the above two components (|pi|, |P|) to calculate the likelihood of the sample alignment displayed :ref:`in the tree <tree_align_p>`. Normally we would have a separate |P| for each edge on the tree, but to keep this calculation simple we just use the one.

We calculate this for the first alignment column in my little example, which has a :teal:`C`, :orange:`T`, :blue:`C` as the observed states. We start by asking what is the likelihood that the ancestral base was a C at this column? We obtain the probability of a C in the ancestor from the |pi| vector.

.. jupyter-execute::

    pi[0, "C"]

Conditioned on having a C, we then extract the probabilities from |P| that correspond to C being observed on the :teal:`green` and :blue:`blue` edges, and changing into T on the :orange:`orange` edge. The likelihood of a C at alignment column 1 [4]_ is specified by this equation

.. margin::
  
    .. [4] The edge from which P is derived is indicated in as a subscript in the table title.

.. math::

    \mathcal{L}_1(\text{C})=\pi_\text{C} \times P_1(C,C) \times P_2(C,T) \times P_3(C,C)

and this code

.. jupyter-execute::

    pi[0, "C"] * P["C", "C"] * P["C", "T"] * P["C", "C"]

This is simply the probability conditioned on whatever the values are in our matrices and vector. We repeat this calculation for T as the ancestral state, i.e.

.. math::

    \mathcal{L}_1(\text{T})=\pi_\text{T} \times P_1(T,C) \times P_2(T,T) \times P_3(T,C)

and

.. jupyter-execute::

    pi[0, "T"] * P["T", "C"] * P["T", "T"] * P["T", "C"]

for A as the ancestral base and then G as the ancestral base. The likelihood under our model for the first position is simply the sum of these individual likelihoods.

.. math::

    \mathcal{L}_1 = \mathcal{L}_1(\text{T}) + \mathcal{L}_1(\text{C}) + \mathcal{L}_1(\text{A}) + \mathcal{L}_1(\text{G})

To obtain the likelihood of the entire alignment we perform the above steps for every alignment column and take the product of all the resulting values (there would be 6 for this sample alignment).

.. math::

    \mathcal{L}_{\text{Alignment}} = \mathcal{L}_1 \times \mathcal{L}_2 \times \mathcal{L}_3 \times \mathcal{L}_4 \times \mathcal{L}_5 \times \mathcal{L}_6

or more simply

.. math::

    \mathcal{L}_{\text{Alignment}} = \prod_{i=1}^6\mathcal{L}_i

For 3 taxa, the calculation is not particularly complicated. If you've got a big tree with many internal nodes, this calculation is solved using a dynamic programming algorithm :cite:`Felsenstein:1981aa`.

So this representation is one of sequence evolution from a common ancestor to the tips. We have described, by specifying the substitution probability matrices, how nucleic acid sequences change in time. We have used the resulting substitution probability matrices to compute the likelihood of observing our data, given the model.

To avoid underflow errors this expression is converted into logs

.. math::

    \log\mathcal{L}_{\text{Alignment}} = \sum_1^6 \log \mathcal{L}_i

and as a result, we talk of log-likelihoods.

The log-likelihood statistic is a summary statistic that represents the accumulated evidence of observing that entire alignment, given the model.

Practical issues
----------------

We typically do not specify our models in terms of |P| matrices – the substitution probability matrices. We typically work with a rate matrix |Q|. While |P| matrices have very good mathematical and statistical properties, they are too "parameter rich" [5]_. They make interrogating the dynamics of the process of divergence more complicated. We can obtain the substitution probability matrix from a rate matrix by the matrix exponential

.. margin::
  
    .. [5] Parameter richness refers to the total number of parameters. Whether a model is too parameter rich, or not, depends on the amount of data being analysed. In general, if we consider a model too parameter rich we mean that we are unlikely to be able to reliably estimate all the parameters. That's a bad thing.

.. math::

    P(t) = \exp^{Qt}

.. index::
    pair: branch length; expected number of substitutions

where |Q| is the instantaneous rate matrix, :math:`\exp` the matrix exponential and :math:`t` is the expected number of substitutions per site.

So now we have slightly revised components of the model. Because we were just dealing with a substitution probability matrix, time was embedded as a part of the matrix. It was not a separate parameter. Now, we have all of those things but we have swapped |Q| **plus** branch lengths for |P|.

We will discuss substitution models in more detail in the next section.

What's this maximising stuff...?
--------------------------------

I'll give you a stripped down example of how this sort of operates. Let's make some very strict assumptions to make the demonstration easier. I assume

- a :ref:`star phylogeny <star_tree>` for three taxa
- the branch length on each edge is identical (so there's only one length)
- the sequences evolve according to the Jukes Cantor substitution model (a very simple model, :ref:`jc69`).
- Jukes-Cantor assumes the nucleotides occur with equal frequency in the ancestor

So we only have one free parameter, the branch length which I will refer to as |t|. I am now going to start with |t|\ =0.001. I compute my |P| matrix for that value of time and then the conditional probability of observing an alignment. I increment |t| by 0.001 and repeat until I get to some upper limit of |t|.

The results of this calculation are shown below with the log-likelihood on the |yaxis| and the branch length (|t|) on the |xaxis|. This is a brute-force "line search" and not how we normally do things!

.. jupyter-execute::
    :hide-code:

    import plotly.express as px
    from numpy import arange
    from cogent3 import get_model, make_tree, load_aligned_seqs

    aln = load_aligned_seqs("data/brca1.fasta", moltype="dna")
    aln = aln.take_seqs(["Human", "Rhesus", "Chimpanzee"])
    aln = aln.omit_gap_pos(allowed_gap_frac=0, motif_length=3)

    jc = get_model("JC69")
    lf = jc.make_likelihood_function(make_tree(tip_names=aln.names))
    lf.set_alignment(aln)
    lf.set_motif_probs(dict(A=0.25,C=0.25,G=0.25,T=0.25))
    lf.set_param_rule("length", is_independent=False)

    lengths = []
    lnLs = []

    for i in arange(0.001, 0.04, 0.001):
        lf.set_param_rule("length", is_independent=False, init=i)
        lengths.append(i)
        lnLs.append(lf.lnL)

    fig = px.line(x=lengths, y=lnLs, labels=dict(x="Branch Length (<i>t</i>)", y="lnL"), width=700, height=400)
    fig.show()

The peak of these data points (when :math:`t \approx 0.015`) is the maximum likelihood. That is, the value of |t| that maximises the likelihood. This value of |t| gets a special label – we call it the maximum likelihood estimator (or MLE) [#]_.

.. [#] Maximum likelihood estimators are typically denoted the caret character as :math:`\hat t`.

When you have a really complex function, a probability model with lots of parameters, you don't have one line search, you have a line search for every parameter. Numerical optimisation algorithms handle that. It's a bit of magic, and it's definitely beyond the scope of this course.

.. todo:: Add a section on global, local optimisation and failure to optimisers, outliers etc..

What are we actually measuring?
-------------------------------

In a statistical sense, when using a likelihood model we are fitting it to the distribution of distinct alignment columns. For example, the :ref:`alignment shown above <tree_align_p>` has 5 distinct alignment columns, one of which occurs twice. In our working through the calculation of the likelihood for an alignment column above, we produced a :math:`\mathcal{L}_i`, the likelihood value for alignment column :math:`i`. This value is the expected frequency of that alignment column under the model.

Our model arrives at those expected values by specifying the relationships amongst the sequences (the tree) and the way sequences change through time (the substitution model). The model is thus measuring variation in the sequence through time.

In a biological sense, it is the factors that influence genetic variation that we measure. Those changes arise from the influence of the :ref:`processes illustrated earlier <mutant_fate>`. When we compare sequences between vertebrate species, for instance, we are observing genetic differences that originated from mutagenic events in sex cells. It is events that occur in the germline that shape the distribution of genetic variation in the next generation. The formation of DNA lesions and their repair in the germline that give rise to mutations and the processes that shape those events shape polymorphism and the processes that shape polymorphism shape substitutions. With these simple models, we measure the aggregate of all of these factors.

Precisely how much we can learn about the origins of genetic variation depends on the model of sequence change that we use. In other words, it is the definition of our substitution models that dictates what information we can extract from genetic variation. We will address that in the next section.

Assumptions
-----------

A single tree topology
    All positions of a sequence share exactly the same evolutionary history with respect to the genealogy. This can be violated when there are recombination events amongst members of a gene family, for instance. Or, in the case of microbes, there have been horizontal (or lateral) gene transfer events.

Independence of alignment columns
    In the calculation of the likelihood of an alignment, we take the product of the likelihoods from all alignment columns. That is an assumption of independence. Stated another way, we assume the alignment columns are evolving independently of each other. We know that's not true. Recall that we previously tested whether nucleotides occurred independently of each other and rejected the null hypothesis in that case.

Independent and identically distributed, or iid
    This is a further refinement of the above. We applied exactly the same model to every alignment column. This corresponds to assuming that every position in the alignment is evolving according to exactly the same process. So we are explicitly imposing the same process for every column of the alignment. Those two conditions are referred to as iid – independent and identically distributed.

Independence between lineages (branches)
    We assume that the different lineages on a tree are not interacting with each other in some way that's affecting the substitution rate.

.. note:: There are other assumptions of the substitution models which we will cover in that section.

------

.. rubric:: Citations

.. bibliography:: /references.bib
    :filter: docname in docnames
    :style: alpha
